from math import floor
from copy import deepcopy
from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes
import random
import math

def product(v1,v2):
    sum=0
    for i in range(0,len(v1)):
        sum+=v1[i]*v2[i]
    return sum


def gaussian_reduce(v1,v2):
    while True:
        m=product(v2,v2)-product(v1,v1)
        if m<0:
            temp=(v1)
            v1=(v2)
            v2=(temp)
        q=product(v1,v2)/product(v1,v1)
        if floor(q)==0:
            return (v1,v2)
        v2=[v2[i]-floor(q)*v1[i] for i in range(0,len(v1))]
        

def gen_key():
    q = getPrime(512)
    upper_bound = int(math.sqrt(q // 2))
    lower_bound = int(math.sqrt(q // 4))
    f = random.randint(2, upper_bound)
    while True:
        g = random.randint(lower_bound, upper_bound)
        if math.gcd(f, g) == 1:
            break
    h = (inverse(f, q)*g) % q
    return (q, h), (f, g)


def encrypt(q, h, m):
    assert m < int(math.sqrt(q // 2))
    r = random.randint(2, int(math.sqrt(q // 2)))
    e = (r*h + m) % q
    return e

def decrypt(q, h, f, g, e):
    a = (f*e) % q
    m = (a*inverse(f, g)) % g
    return m


# consider two basis (1,h) and (0,-p)
# i will prove that the sv is (h,g)
# suppose (h1,g1) is generated by running Gaussian reduction
# WLOG, we ignore the case h1<0 and g1<0

q=7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257
h=2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800    
e=5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523
v = [1, h]
u = [0,-q]
r=gaussian_reduce(v,u)
f=r[0][0]
g=r[0][1]
m=decrypt(q,h,f,g,e)
decrypted=long_to_bytes(m)
print(decrypted)

